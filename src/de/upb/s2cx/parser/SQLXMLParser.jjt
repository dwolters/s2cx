options{  JDK_VERSION = "1.5";  static = false;  MULTI = false;}PARSER_BEGIN(SQLXMLParser)package de.upb.s2cxml.parser;import de.upb.s2cxml.parser.sql.*;import de.upb.s2cxml.parser.sql.xml.*;import gnu.trove.stack.TByteStack;import gnu.trove.stack.array.TByteArrayStack;public class SQLXMLParser{  private static TByteStack xmlAggStack = new TByteArrayStack();  private static TByteStack depth = new TByteArrayStack();  private static void inc()  {	xmlAggStack.push((byte)(xmlAggStack.pop()+1));	if(xmlAggStack.peek() > depth.peek())	{	  	depth.pop();			depth.push(xmlAggStack.peek());	}  }  private static void dec()  {	xmlAggStack.push((byte)(xmlAggStack.pop()-1));  }  private static void push()  {	xmlAggStack.push((byte)0);	depth.push((byte)0);  }  private static byte pop()  {    xmlAggStack.pop();	return depth.pop();  }  public Statement parse() throws ParseException  {	TableFactory.reset();	return root();  }}PARSER_END(SQLXMLParser)SKIP :{  " "| "\t"| "\n"| "\r"}TOKEN : /* LITERALS */{  < CHAR :    (      < UPPERCHAR >    | < LOWERCHAR >    ) >| < NUMBER : (< DIGIT >)+ >| < LOWERCHAR : [ "a"-"z" ] >| < UPPERCHAR : [ "A"-"Z" ] >| < DIGIT : [ "0"-"9" ] >| < AS : "AS" >| < COMMA : "," >| < SELECT : "SELECT" >| < FROM : "FROM" >| < WHERE : "WHERE" >| < ORDERBY : "ORDER BY" >| < GROUPBY : "GROUP BY" >| < ASC : "ASC" >| < DESC : "DESC" >| < NAME : "NAME" >| < DATE : "DATE" >| < XMLELEMENT : "XMLELEMENT" >| < XMLATTRIBUTES : "XMLATTRIBUTES" >| < XMLFOREST : "XMLFOREST" >| < XMLCONCAT : "XMLCONCAT" >| < XMLAGG : "XMLAGG" >| < SUM : "SUM" >| < AVG : "AVG" >| < MIN : "MIN" >| < MAX : "MAX" >| < COUNT : "COUNT" >| < EXISTS : "EXISTS" >| < STRING :    "'"    (      < CHAR >    | < DIGIT >    | " "    | "%"    | "#"    | "-"    | "_"    )*    "'" >| < IDENTIFIER :    "\""    (      < CHAR >    | < DIGIT >    | "_"    )+    "\"" >| < DOT : "." >| < LEFT_PAR : "(" >| < RIGHT_PAR : ")" >| < EQUAL : "=" >| < NOTEQUAL : "<>" >| < GREATER : ">" >| < LESSER : "<" >| < LESSEQUAL : "<=" >| < GREATEREQUAL : ">=" >| < LIKE : "LIKE" >| < AND : "AND" >| < OR : "OR" >| < NOT : "NOT" >| < IN : "IN" >| < ASTERISK : "*" >| < SOLIDUS : "/" >| < PLUS : "+" >| < MINUS : "-" >}Statement root() :{  Statement s;}{  s = select() < EOF >  {    return s;  }}Statement select() :{  push();  Statement s = new Statement();  FromClause from = new FromClause();  OrderByClause orderBy = null;  WhereClause where = null;  GroupByClause groupBy = null;  Table t;  Value v;}{  < SELECT > v = xmlValue()  {    s.add(v);  }  (    < COMMA > v = value()    {      s.add(v);    }  )*  < FROM > t = table()  {    from.add(t);  }  (    < COMMA > t = table()    {      from.add(t);  	}  )*  (    where = whereClause()  )?  (    groupBy = groupByClause()  )?  (	orderBy = orderByClause()  )?  {    s.setFromClause(from);    s.setOrderByClause(orderBy);    s.setGroupByClause(groupBy);    s.setWhereClause(where);    s.setXmlAggDepth(pop());    return s;  }}Table table() :{  Token name;  Token alias;}{  name = < IDENTIFIER > alias = < IDENTIFIER >  {    return TableFactory.createTable(name.image, alias.image);  }}Column column() :{  Token tableAlias;  Token columnName;}{  tableAlias = < IDENTIFIER > < DOT > columnName = < IDENTIFIER >  {   Column c = ColumnFactory.createColumn(columnName.image, TableFactory.getTableByAlias(tableAlias.image));   return c;   }}XmlValue additiveTerm() :{  Token op = null;  XmlValue left = null;  XmlValue right = null;}{  left = term()  (    op = < PLUS > right = additiveTerm() |    op = < MINUS > right = additiveTerm()  )?  {    if(right != null)    {      	  Term t = new Term();	  t.setOperator(op.image);	  t.setLeft(left);	  t.setRight(right);	  return t;	}	else		return left;  }}XmlValue term() :{  Token op = null;  XmlValue left = null;  XmlValue right = null;}{  left = factor()  (    op = < ASTERISK > right = term() |  	op = < SOLIDUS > right = term()  )?  {    if(right != null)    {      	  Term t = new Term();	  t.setOperator(op.image);	  t.setLeft(left);	  t.setRight(right);	  return t;	}	else		return left;  }}XmlValue factor() :{  XmlValue value;}{  (< MINUS > | < PLUS >)? value = value()  {    //TODO add sign    return value;  }}WhereClause whereClause() :{  WhereClause where = new WhereClause();  Condition c;}{  < WHERE > c = conditions()  {    where.setCondition(c);    return where;  }}GroupByClause groupByClause() :{  GroupByClause groupBy = new GroupByClause();  Column c;}{  < GROUPBY > c = column()  {    groupBy.add(c);  }  (    < COMMA > c = column()    {      groupBy.add(c);    }  )*  {	return groupBy;  }}OrderByClause orderByClause() :{  Token order = null;  Column c;  OrderByClause orderBy = new OrderByClause();}{  < ORDERBY > c = column()  (    order = < ASC >  | order = < DESC >  )?  {    orderBy.add(ColumnFactory.createSortColumn(c,(order == null || order.image.equals("ASC") ? true : false)));    order = null;  }  (    < COMMA > c = column()    (      order = < ASC >    | order = < DESC >    )?    {      orderBy.add(ColumnFactory.createSortColumn(c,(order == null || order.image.equals("ASC") ? true : false)));      order = null;  	}  )*  {    return orderBy;  }}Condition conditions() :{  Condition left = null;  Condition right = null;}{  left = andCondition()  (    < OR > right = conditions()  )?  {    if(right != null)    {      return new ConditionTree<Condition, Condition >("OR", left, right);    }    else      return left;  }}Condition andCondition() :{  Condition left = null;  Condition right = null;}{  (    LOOKAHEAD(2)    (      < LEFT_PAR > left = conditions() < RIGHT_PAR >      {        left = new ParenthesizedCondition(left);      }    )  |    (      left = condition()      (        < AND > right = andCondition()      )?    )  )  {    if(right != null)    {      return new ConditionTree<Condition, Condition >("AND", left, right);    }    else      return left;  }}Condition condition() :{  Condition c = null;  Condition left;}{ (   (  	left = value()    (      c = valueCondition(left)  	| c = columnCondition(left)  	)	) |    c = existsCondition() ){  return c;}}Condition valueCondition(Condition left) :{  ConditionTree<Condition, Condition > t = new ConditionTree<Condition, Condition >();  Condition right;  String op;}{  op = relationalOperator() right = value()  {    t.setLeft(left);    t.setRight(right);    t.setOperator(op);    return t;  }}Condition existsCondition() :{  Statement s;}{  < EXISTS > < LEFT_PAR > s = select() < RIGHT_PAR >  {    return new ExistsCondition(s);  }}Condition columnCondition(Condition left) :{  Condition con;  Column col;  Token negated =  null;  Condition s;  Value like;}{  (negated = < NOT >)?  (    (      s = inCondition()   	  {   	    ConditionTree<Condition, Condition > c1 = new ConditionTree<Condition, Condition >();   	    c1.setOperator("IN");   	    c1.setLeft(left);   	    c1.setRight(s);   	    c1.setNegated(negated != null);   	    con = c1;   	  }    )  | (      like = likeCondition()  	  {  	    ConditionTree<Condition, Value > c2 = new ConditionTree<Condition, Value>();   	    c2.setOperator("LIKE");   	    c2.setLeft(left);   	    c2.setRight(like);   	    c2.setNegated(negated != null);   	    con = c2;  	  }    )  )  {    return con;  }}Condition inCondition() :{  Condition c;}{  < IN > < LEFT_PAR > (c = array() | c = select()) < RIGHT_PAR >  {    return c;  }}Value likeCondition() :{  Value v;}{  < LIKE > v = value()  {    return v;  }}String relationalOperator() :{ Token op;}{  (    op = < EQUAL >  | op = < NOTEQUAL >  | op = < GREATER >  | op = < LESSER >  | op = < LESSEQUAL >  | op = < GREATEREQUAL >  )  {    return op.image;  }}XmlElementFunction xmlElement() :{  Token name;  XmlValue value = null;  XmlElementFunction function = new XmlElementFunction();}{  < XMLELEMENT > < LEFT_PAR > < NAME > name = < IDENTIFIER >  (    LOOKAHEAD(2)    < COMMA > xmlAttributes(function)  )?  (    < COMMA > value = xmlValue()    {      function.add(value);    }  )*  < RIGHT_PAR >  {    function.setName(name.image);    return function;  }}void xmlAttributes(XmlElementFunction f) :{AbstractXmlAttribute att;}{  < XMLATTRIBUTES > < LEFT_PAR >  att = xmlAttribute()  {    f.addAttribute(att);  }  (    < COMMA > att = xmlAttribute()    {      f.addAttribute(att);    }  )*  < RIGHT_PAR >}AbstractXmlAttribute xmlAttribute() :{  Value v;  Token alias;}{  v = value() < AS > alias = < IDENTIFIER >  {    if(v instanceof StringValue)    {      return new XmlStringAttribute(alias.image, v.getValue());    } else if(v instanceof Column) {      return new XmlColumnAttribute(alias.image, (Column)v);    } else if(v instanceof SqlFunction) {      return new XmlFunctionAttribute(alias.image, (SqlFunction)v);    }  }}XmlConcatFunction xmlConcat() :{  XmlValue v;  XmlConcatFunction f = new XmlConcatFunction();}{  < XMLCONCAT > < LEFT_PAR > v = xmlValue()  {    f.add(v);  }  (    < COMMA > v = xmlValue()    {      f.add(v);    }  )+  < RIGHT_PAR >  {    return f;  }}XmlForestFunction xmlForest() :{  XmlForestFunction f = new XmlForestFunction();  XmlElementWrapper v;}{  < XMLFOREST > < LEFT_PAR > v = xmlForestElement()  {    f.add(v);  }  (    < COMMA > v = xmlForestElement()    {      f.add(v);    }  )*  < RIGHT_PAR >  {    return f;  }}XmlElementWrapper xmlForestElement() :{  Token alias;  XmlValue v;}{  v = xmlValue() < AS > alias = < IDENTIFIER >  {    return new XmlElementWrapper(v, alias.image);  }}XmlAggFunction xmlAgg() :{  OrderByClause orderBy = null;  XmlAggFunction f = new XmlAggFunction();  XmlValue v;  inc();}{  < XMLAGG > < LEFT_PAR > v = xmlValue()  (    orderBy = orderByClause()  )?  < RIGHT_PAR >  {    f.setParameter(v);    f.setOrderByClause(orderBy);    dec();    return f;  }}SqlFunction sqlFunction() :{  Token name;  XmlValue value;  SqlFunction f;  Column c = null;}{  (    (    name = < COUNT > < LEFT_PAR > (c = column() | < ASTERISK >) < RIGHT_PAR >    {      f = new SqlFunction(name.image, c == null ? new StringValue("*") : c);    }  )|  (    (      name = < SUM >    | name = < MIN >    | name = < MAX >    | name = < AVG >    )    < LEFT_PAR > value = additiveTerm() < RIGHT_PAR >    {            f = new SqlFunction(name.image, value);    }  ))  {    return f;  }}XmlValue value() :{  Token strValue = null;  Column c = null;  Statement s = null;  XmlValue value = null;  Token date = null;}{  (   strValue = < STRING >  | strValue = < NUMBER >  | < DATE > date = < STRING >   | c = column()  | value = sqlFunction()  |    (      < LEFT_PAR >      (        (value = select() | value = additiveTerm())        {          value = new ParanthesizedValue(value);         }      )      < RIGHT_PAR >    )  )  {    if(strValue != null)    	return new StringValue(strValue.image);    else if(c != null)    	return c;    else if(value != null)    	return value;    else if(date != null)    	return new DateValue(date.image);  }}XmlValue array() : {  Token value;  ArrayValue array = new ArrayValue();}{  (    value = < STRING > | value = < NUMBER >  )  {    array.add(value.image);  }  {      }  (    < COMMA >    (      value = < STRING > | value = < NUMBER >	)	{	  array.add(value.image);	}  )+  {	return array;  }}XmlValue xmlValue() :{  XmlValue v;}{  (    v = value()	| v = xmlElement()	| v = xmlConcat()	| v = xmlForest()	| v = xmlAgg()  )  {    return v;  }}